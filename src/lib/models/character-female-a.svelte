<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 static/avatars/character-female-a.glb
Modified to support dynamic GLTF URL via prop
-->

<script>
  import { Group } from "three";
  import { T, useTask } from "@threlte/core";
  import { useGltf, useGltfAnimations } from "@threlte/extras";

  import { AutoColliders, RigidBody } from "@threlte/rapier";

  let {
    url, // Nouvelle prop pour le chemin GLTF
    animation = "idle",
    fallback,
    error,
    children,
    ref = $bindable(),
    ...props
  } = $props();

  ref = new Group();

  const gltf = useGltf(url); // Utiliser l'URL passée via prop

  export const { actions, mixer } = useGltfAnimations(gltf, ref);

  // Mettre à jour l'animation lorsque la prop change
  $effect(() => {
    if ($actions && $actions[animation]) {
      // Arrêter toutes les animations précédentes
      Object.values($actions).forEach((action) => action.stop());
      // Jouer l'animation spécifiée
      $actions[animation].reset().fadeIn(0.5).play();
    }
  });

  // Mettre à jour le mixer à chaque frame
  useTask((delta) => {
    if (mixer) {
      mixer.update(delta);
    }
  });
</script>

<T is={ref} dispose={false} {...props}>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <T.Group name="character-female-a">
      <T.Group name="character-female-a_1">
        <T is={gltf.nodes.root} />
        <AutoColliders shape={"cuboid"}>
          <T.SkinnedMesh
            name="body-mesh"
            geometry={gltf.nodes["body-mesh"].geometry}
            material={gltf.materials.colormap}
            skeleton={gltf.nodes["body-mesh"].skeleton}
            castShadow
            receiveShadow
          />
        </AutoColliders>
        
        <T.SkinnedMesh
          name="head-mesh"
          geometry={gltf.nodes["head-mesh"].geometry}
          material={gltf.materials.colormap}
          skeleton={gltf.nodes["head-mesh"].skeleton}
          castShadow
          receiveShadow
        />
      </T.Group>
    </T.Group>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T>